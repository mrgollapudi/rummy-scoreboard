<script type="text/javascript">
        var gk_isXlsx = false;
        var gk_xlsxFileLookup = {};
        var gk_fileData = {};
        function filledCell(cell) {
          return cell !== '' && cell != null;
        }
        function loadFileData(filename) {
        if (gk_isXlsx && gk_xlsxFileLookup[filename]) {
            try {
                var workbook = XLSX.read(gk_fileData[filename], { type: 'base64' });
                var firstSheetName = workbook.SheetNames[0];
                var worksheet = workbook.Sheets[firstSheetName];

                // Convert sheet to JSON to filter blank rows
                var jsonData = XLSX.utils.sheet_to_json(worksheet, { header: 1, blankrows: false, defval: '' });
                // Filter out blank rows (rows where all cells are empty, null, or undefined)
                var filteredData = jsonData.filter(row => row.some(filledCell));

                // Heuristic to find the header row by ignoring rows with fewer filled cells than the next row
                var headerRowIndex = filteredData.findIndex((row, index) =>
                  row.filter(filledCell).length >= filteredData[index + 1]?.filter(filledCell).length
                );
                // Fallback
                if (headerRowIndex === -1 || headerRowIndex > 25) {
                  headerRowIndex = 0;
                }

                // Convert filtered JSON back to CSV
                var csv = XLSX.utils.aoa_to_sheet(filteredData.slice(headerRowIndex)); // Create a new sheet from filtered array of arrays
                csv = XLSX.utils.sheet_to_csv(csv, { header: 1 });
                return csv;
            } catch (e) {
                console.error(e);
                return "";
            }
        }
        return gk_fileData[filename] || "";
        }
        </script><!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Rummy Score Board</title>
    <style>
        :root {
            --tw-bg-opacity: 1;
            --tw-text-opacity: 1;
            --tw-border-opacity: 1;
        }
        body {
            font-family: 'Verdana', sans-serif;
            background: linear-gradient(135deg, #ff4d4d, #4ecdc4, #4169e1, #c71585);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start;  /* Align to top */
            padding: 0;                   /* Optional: remove body padding */
            margin: 0;
            animation: gradientShift 10s ease infinite;
            background-size: 200% 200%;
        }
        @keyframes gradientShift {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }
        .banner {
            background: linear-gradient(to right, #ffd700, #008000);
            width: 100%;
            padding: 0.25rem 1rem;
            display: flex;
            align-items: center;
            justify-content: center;
            position: sticky;
            top: 0;
            z-index: 10;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
        }
        .banner-content {
            display: flex;
            align-items: center;
            gap: 1.5rem;
        }
        .card-symbols {
            font-size: 2rem;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
        }
        .card-symbols.clubs, .card-symbols.spades {
            color: #000000;
        }
        .card-symbols.hearts, .card-symbols.diamonds {
            color: #ff0000;
        }
        .bg-white { 
            background: rgba(255, 255, 255, 0.95); 
            border: 2px solid #ffd700;
            transition: transform 0.3s ease; 
        }
        .bg-white:hover { transform: scale(1.02); }
        .bg-gray-100 { background: linear-gradient(#e0e0e0, #f0f0f0); }
        .bg-gray-200 { background: linear-gradient(#d0d0d0, #e0e0e0); }
        .bg-white-leaderboard { background: #ffffff; }
        .bg-white-leaderboard td {
            font-size: 0.7875rem; /* 10% less than 0.875rem */
            font-style: italic;
        }
        .bg-light-purple { background: #f3e5f5; }
        .bg-light-purple td {
            font-size: 0.7875rem;
            font-style: italic;
        }
        .bg-blue-500 { 
            background: #1e90ff; 
            transition: background 0.3s ease, box-shadow 0.3s ease; 
        }
        .bg-green-500 { 
            background: #00ff7f; 
            transition: background 0.3s ease, box-shadow 0.3s ease; 
        }
        .bg-green-700 { 
            background: #006400; 
            transition: background 0.3s ease, box-shadow 0.3s ease; 
        }
        .bg-red-500 { 
            background: #ff4040; 
            transition: background 0.3s ease, box-shadow 0.3s ease; 
        }
        .bg-yellow-500 { 
            background: #ffd700; 
            transition: background 0.3s ease, box-shadow 0.3s ease; 
        }
        .bg-amber-500 { 
            background: #ff8c00; 
            transition: background 0.3s ease, box-shadow 0.3s ease; 
        }
        .bg-gray-500 { 
            background: #696739; 
            transition: background 0.3s ease, box-shadow 0.3s ease; 
        }
        .bg-purple-500 { 
            background: #800080; 
            transition: background 0.3s ease, box-shadow 0.3s ease; 
        }
        .hover\:bg-blue-600:hover { 
            background: #1c86ee; 
            box-shadow: 0 0 10px rgba(28, 134, 238, 0.7); 
        }
        .hover\:bg-green-600:hover { 
            background: #00cd66; 
            box-shadow: 0 0 10px rgba(0, 205, 102, 0.7); 
        }
        .hover\:bg-green-800:hover { 
            background: #004d00; 
            box-shadow: 0 0 10px rgba(0, 77, 0, 0.7); 
        }
        .hover\:bg-red-600:hover { 
            background: #cd2626; 
            box-shadow: 0 0 10px rgba(205, 38, 38, 0.7); 
        }
        .hover\:bg-yellow-600:hover { 
            background: #cdad00; 
            box-shadow: 0 0 10px rgba(205, 173, 0, 0.7); 
        }
        .hover\:bg-gray-600:hover { 
            background: #4f4f4f; 
            box-shadow: 0 0 10px rgba(79, 79, 79, 0.7); 
        }
        .hover\:bg-purple-600:hover { 
            background: #6a006a; 
            box-shadow: 0 0 10px rgba(106, 0, 106, 0.7); 
        }
        .text-white { color: #ffffff; text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.3); }
        .text-red-500 { color: #ff4040; }
        .text-gray-600 { color: #333333; }
        .text-3xl { font-size: 2rem; line-height: 2.5rem; }
        .text-2xl { font-size: 1.5rem; line-height: 2rem; }
        .text-xl { font-size: 1.25rem; line-height: 1.75rem; }
        .eliminated-score { color: #a9a9a9; font-style: italic; }
        .lowest-total { color: #0000ff; font-weight: bold; }
        .highest-total { color: #800000; font-weight: bold; }
        .no-margin-right:last-child { margin-right: -16px; }
        .read-only .editable { display: none; }
        @media (max-width: 360px) {
            #playerName { width: 100%; max-width: 280px; }
            #scoreButtons { flex-wrap: wrap; justify-content: center; }
        }
        .sr-only { position: absolute; width: 1px; height: 1px; padding: 0; margin: -1px; overflow: hidden; clip: rect(0, 0, 0, 0); }
        #scoreButtons { justify-content: center; }
        .container { width: 100%; max-width: 4xl; }
        .mb-4 { margin-bottom: 1rem; }
        .flex { display: flex; }
        .flex-col { flex-direction: column; }
        .flex-row { flex-direction: row; }
        .flex-wrap { flex-wrap: wrap; }
        .gap-2 { gap: 0.5rem; }
        .gap-1 { gap: 0.25rem; }
        .w-full { width: 100%; }
        .max-w-4xl { max-width: 56rem; }
        .p-4 { padding: 1rem; }
        .p-1 { padding: 0.25rem; }
        .px-4 { padding-left: 1rem; padding-right: 1rem; }
        .py-2 { padding-top: 0.5rem; padding-bottom: 0.5rem; }
        .px-2 { padding-left: 0.5rem; padding-right: 0.5rem; }
        .py-1 { padding-top: 0.25rem; padding-bottom: 0.25rem; }
        .mt-2 { margin-top: 0.5rem; }
        .mt-1 { margin-top: 0.25rem; }
        .mb-2 { margin-bottom: 0.5rem; }
        .rounded { border-radius: 0.25rem; }
        .border { border-width: 1px; }
        .border-red-500 { border-color: #ff4040; }
        .shadow-lg { box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05); }
        .font-bold { font-weight: 700; }
        .font-semibold { font-weight: 600; }
        .font-medium { font-weight: 500; }
        .text-sm { font-size: 0.875rem; }
        .text-lg { font-size: 1.125rem; }
        .text-center { text-align: center; }
        .grid { display: grid; }
        .grid-cols-1 { grid-template-columns: repeat(1, minmax(0, 1fr)); }
        .sm\:grid-cols-2 { grid-template-columns: repeat(2, minmax(0, 1fr)); }
        .md\:grid-cols-3 { grid-template-columns: repeat(3, minmax(0, 1fr)); }
        .overflow-x-auto { overflow-x: auto; }
        .hidden { display: none; }
        .justify-between { justify-content: space-between; }
        .items-center { align-items: center; }
        table { width: 100%; border-collapse: collapse; }
        th, td { border: 1px solid #d0d0d0; }
    </style>
</head>
<body>
    <div class="banner">
        <div class="banner-content">
            <div class="card-symbol-group">
                <span class="card-symbols clubs">♣</span>
                <span class="card-symbols hearts">♥</span>
            </div>
            <h1 class="text-2xl font-bold text-white text-center">Rummy Score Board</h1>
            <div class="card-symbol-group">
                <span class="card-symbols diamonds">♦</span>
                <span class="card-symbols spades">♠</span>
            </div>
        </div>
    </div>

    <div style="padding-left: 1.5rem;" class="bg-white rounded-lg shadow-lg p-4 w-full max-w-4xl container">
        <div id="targetDisplay" class="text-xl font-bold text-center mb-2 hidden editable">
            Target Score: <span id="targetValue"></span>
        </div>

        <!-- Player Setup -->
        <div id="playerSetup" class="mb-4 editable">
            <h2 class="text-xl font-semibold mb-2">Game Setup</h2>
            <div class="flex flex-col gap-2">
                <div class="flex flex-wrap gap-2">
                    <label for="playerName" class="sr-only">Player Names</label>
                    <input id="playerName" type="text" placeholder="Enter player names (e.g., Alice, Bob, Charlie)" class="border rounded p-2" style="width: 325px; height: 3rem;">
                    <label for="betAmount" class="sr-only">Bet Amount</label>
                    <input id="betAmount" type="number" placeholder="Bet per player ($)" value="10" class="border rounded p-2" style="width: 100px;" min="0" step="0.01">
                    <button onclick="addPlayer()" class="bg-blue-500 text-white px-2 py-2 rounded hover:bg-blue-600 font-bold no-margin-right" style="width: 66px; text-align: center;">Add Players</button>
                </div>
                <div id="playerError" class="text-red-500 border-red-500 mt-1 hidden"></div>
                <div class="flex gap-2">
                    <label for="targetScore" class="sr-only">Target Score</label>
                    <input id="targetScore" type="number" placeholder="Enter target score (min 100)" class="border rounded p-2" style="width: 120px;">
                    <button onclick="startGame()" class="bg-green-700 text-white px-4 py-2 rounded hover:bg-green-800 font-bold">Start Game</button>
                </div>
                <div id="targetError" class="text-red-500 border-red-500 mt-1 hidden"></div>
            </div>
            <div id="playerList" class="grid grid-cols-1 sm:grid-cols-2 md:grid-cols-3 gap-2 mt-2"></div>
        </div>

        <!-- Score Input -->
        <div id="scoreInput" class="mb-4 hidden editable">
            <h2 class="text-xl font-semibold mb-2" id="scoreInputTitle">Enter Scores for Round <span id="roundNumber">1</span></h2>
            <div id="scoreForm" class="flex flex-row gap-2 overflow-x-auto"></div>
            <div id="errorMessage" class="text-red-500 border-red-500 mt-1 hidden"></div>
            <div class="flex gap-2 mt-2" id="scoreButtons"></div>
        </div>

        <!-- Leaderboard -->
        <div id="leaderboard" class="mb-4">
            <h2 class="text-xl font-semibold mb-2">Leaderboard - <span id="leaderboardGameName">Untitled</span> (Total Bet: $<span id="totalBetAmount">0.00</span>)</h2>
            <div class="leaderboard-table">
                <table>
                    <thead id="leaderboardHead"></thead>
                    <tbody id="leaderboardTable"></tbody>
                </table>
            </div>
            <div id="shareLeaderboard" class="mt-2 editable">
                <button onclick="generateShareLink()" class="bg-purple-500 text-white px-4 py-2 rounded hover:bg-purple-600">Share Score Board</button>
            </div>
        </div>

        <!-- Game Over -->
        <div id="gameOver" class="hidden editable">
            <h2 class="text-xl font-semibold mb-2">Game Over!</h2>
            <p id="winnerText" class="text-lg"></p>
            <div id="winningsText" class="text-lg mt-1"></div>
            <div id="gameOverButtons" class="flex gap-2 mt-2"></div>
        </div>

        <!-- Game History -->
        <div id="gameHistory" class="mb-4">
            <h2 class="text-xl font-semibold mb-2">Game History</h2>
            <div class="history-table">
                <table>
                    <thead>
                        <tr class="bg-gray-200">
                            <th class="p-1">Game Name</th>
                            <th class="p-1">Date-Time</th>
                            <th class="p-1">Target Score</th>
                            <th class="p-1">Result</th>
                            <th class="p-1">Action</th>
                        </tr>
                    </thead>
                    <tbody id="historyTable"></tbody>
                </table>
            </div>
        </div>

        <!-- Footer -->
        <footer class="footer">
            Copyright © 2025 MRGollapudi. All rights reserved.
        </footer>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.min.js"></script>
    <script type="text/javascript">
        var gk_isXlsx = false;
        var gk_xlsxFileLookup = {};
        var gk_fileData = {};
        function filledCell(cell) {
            return cell !== '' && cell != null;
        }
        function loadFileData(filename) {
            if (gk_isXlsx && gk_xlsxFileLookup[filename]) {
                try {
                    var workbook = XLSX.read(gk_fileData[filename], { type: 'base64' });
                    var firstSheetName = workbook.SheetNames[0];
                    var worksheet = workbook.Sheets[firstSheetName];
                    var jsonData = XLSX.utils.sheet_to_json(worksheet, { header: 1, blankrows: false, defval: '' });
                    var filteredData = jsonData.filter(row => row.some(filledCell));
                    var headerRowIndex = filteredData.findIndex((row, index) =>
                        row.filter(filledCell).length >= filteredData[index + 1]?.filter(filledCell).length
                    );
                    if (headerRowIndex === -1 || headerRowIndex > 25) {
                        headerRowIndex = 0;
                    }
                    var csv = XLSX.utils.aoa_to_sheet(filteredData.slice(headerRowIndex));
                    csv = XLSX.utils.sheet_to_csv(csv);
                    return csv;
                } catch (e) {
                    console.error(e);
                    return "";
                }
            }
            return gk_fileData[filename] || "";
        }
    </script>
    <script>
        let players = [];
        let round = 1;
        let gameStarted = false;
        let roundScores = [];
        let TARGET_SCORE = null;
        let REJOIN_THRESHOLD = null;
        let gameName = '';
        let startDateTime = null;
        let isEditing = false;
        let gameHistory = [];
        let isReadOnly = false;
        const MAX_PLAYERS = 10;
        const MAX_SHARED_GAMES = 100;

        // Cached DOM elements
        const els = {
            playerSetup: document.getElementById('playerSetup'),
            scoreInput: document.getElementById('scoreInput'),
            gameOver: document.getElementById('gameOver'),
            targetScore: document.getElementById('targetScore'),
            targetDisplay: document.getElementById('targetDisplay'),
            targetValue: document.getElementById('targetValue'),
            targetError: document.getElementById('targetError'),
            playerName: document.getElementById('playerName'),
            betAmount: document.getElementById('betAmount'),
            playerError: document.getElementById('playerError'),
            playerList: document.getElementById('playerList'),
            scoreForm: document.getElementById('scoreForm'),
            scoreInputTitle: document.getElementById('scoreInputTitle'),
            errorMessage: document.getElementById('errorMessage'),
            scoreButtons: document.getElementById('scoreButtons'),
            leaderboardHead: document.getElementById('leaderboardHead'),
            leaderboardTable: document.getElementById('leaderboardTable'),
            leaderboardGameName: document.getElementById('leaderboardGameName'),
            totalBetAmount: document.getElementById('totalBetAmount'),
            shareLeaderboard: document.getElementById('shareLeaderboard'),
            winnerText: document.getElementById('winnerText'),
            winningsText: document.getElementById('winningsText'),
            historyTable: document.getElementById('historyTable'),
            gameOverButtons: document.getElementById('gameOverButtons')
        };

        // Format bet amount input
        els.betAmount.addEventListener('input', () => {
            if (els.betAmount.value && !isReadOnly) {
                els.betAmount.value = parseFloat(els.betAmount.value).toFixed(2);
            }
        });

        function formatName(name) {
            return name.charAt(0).toUpperCase() + name.slice(1).toLowerCase();
        }

        function getPlayerDisplayName(player) {
            const formattedName = formatName(player.name);
            return player.rejoinCount > 0 ? `${formattedName} (R${player.rejoinCount})` : formattedName;
        }

        function calculateTotalBetAmount() {
            return players.reduce((sum, player) => sum + player.betAmount, 0).toFixed(2);
        }

        function calculateWinnings() {
            const activePlayers = players.filter(p => !p.eliminated);
            const totalBetAmount = parseFloat(calculateTotalBetAmount());
            const initialBet = players.length > 0 ? players[0].initialBetAmount : 0;
            const winnings = [];

            // Initialize winnings: each player loses their bet amount
            players.forEach(player => {
                winnings.push({
                    name: getPlayerDisplayName(player),
                    winnings: -player.betAmount
                });
            });

            // Check if any active players have drops
            const hasDrops = activePlayers.some(player => 
                Math.floor((TARGET_SCORE - player.totalScore) / 24) > 0
            );

            if (!hasDrops && activePlayers.length > 0) {
                // No drops: equally distribute total bet amount among active players
                const equalShare = totalBetAmount / activePlayers.length;
                activePlayers.forEach(player => {
                    const playerWinnings = winnings.find(w => w.name === getPlayerDisplayName(player));
                    playerWinnings.winnings += equalShare;
                });
            } else {
                // Existing logic: 40% elimination rule
                const eliminatedPlayers = players.filter(p => p.eliminated);
                if (eliminatedPlayers.length / players.length < 0.4) {
                    return null;
                }

                const playerDrops = activePlayers.map(player => ({
                    name: getPlayerDisplayName(player),
                    drops: Math.max(0, Math.round(Math.floor((TARGET_SCORE - player.totalScore) / 24)))
                }));
                const totalNonZeroDrops = playerDrops.reduce((sum, p) => sum + p.drops, 0);

                if (activePlayers.length > 0) {
                    const remainingPool = totalBetAmount - (initialBet * activePlayers.length);
                    activePlayers.forEach(player => {
                        const playerWinnings = winnings.find(w => w.name === getPlayerDisplayName(player));
                        playerWinnings.winnings += initialBet;
                        if (totalNonZeroDrops > 0 && remainingPool > 0) {
                            const playerDrop = playerDrops.find(p => p.name === getPlayerDisplayName(player)).drops;
                            playerWinnings.winnings += (playerDrop / totalNonZeroDrops) * remainingPool;
                        }
                    });
                }
            }

            winnings.forEach(w => {
                w.winnings = parseFloat(w.winnings.toFixed(2));
            });

            return winnings;
        }

        function generateRandomId() {
            const sharedGames = JSON.parse(sessionStorage.getItem('rummySharedGames') || '{}');
            let id;
            do {
                id = Math.floor(100000 + Math.random() * 9000000).toString(); // 6-7 digits
            } while (sharedGames[id]);
            return id;
        }

        function saveSharedGame(gameData) {
            let sharedGames = JSON.parse(sessionStorage.getItem('rummySharedGames') || '{}');
            const id = generateRandomId();

            // Limit to MAX_SHARED_GAMES
            const keys = Object.keys(sharedGames);
            if (keys.length >= MAX_SHARED_GAMES) {
                const oldestKey = keys[0];
                delete sharedGames[oldestKey];
            }

            sharedGames[id] = gameData;
            try {
                sessionStorage.setItem('rummySharedGames', JSON.stringify(sharedGames));
            } catch (e) {
                console.error('Storage error:', e);
                alert('Storage limit reached. Clear history or try again.');
                return null;
            }
            return id;
        }

        function showCopyPrompt(shareUrl) {
            // Create a temporary input element to facilitate copying
            const tempInput = document.createElement('input');
            tempInput.value = shareUrl;
            tempInput.style.position = 'absolute';
            tempInput.style.left = '-9999px';
            document.body.appendChild(tempInput);
            tempInput.select();
            try {
                document.execCommand('copy');
                alert('Shareable link copied to clipboard: ' + shareUrl);
            } catch (err) {
                // Fallback to prompt if execCommand fails
                prompt('Failed to copy automatically. Press Ctrl+C to copy the shareable link:', shareUrl);
            } finally {
                document.body.removeChild(tempInput);
            }
        }

        function generateShareLink() {
            if (!gameStarted) {
                alert('Start a game to share the score board.');
                return;
            }
            const gameData = {
                gameName,
                startDateTime,
                targetScore: TARGET_SCORE,
                totalBetAmount: calculateTotalBetAmount(),
                players: players.map(p => ({
                    name: p.name,
                    initialBetAmount: p.initialBetAmount,
                    betAmount: p.betAmount,
                    totalScore: p.totalScore,
                    roundsWon: p.roundsWon,
                    eliminated: p.eliminated,
                    rejoinCount: p.rejoinCount,
                    lastEliminatedRound: p.lastEliminatedRound,
                    rejoinRounds: p.rejoinRounds
                })),
                roundScores: roundScores.map(round => ({ ...round }))
            };
            const id = saveSharedGame(gameData);
            if (!id) return;
            const shareUrl = `${window.location.href.split('?')[0]}?id=${id}`;
            if (navigator.clipboard && navigator.clipboard.write) {
                navigator.clipboard.write(shareUrl).then(() => {
                    alert('Shareable link copied to clipboard: ' + shareUrl);
                }).catch(() => {
                    showCopyPrompt(shareUrl);
                });
            } else {
                showCopyPrompt(shareUrl);
            }
        }

        function generateHistoryShareLink(startDateTime) {
            const game = gameHistory.find(g => g.startDateTime === startDateTime);
            if (!game) {
                alert('Game not found.');
                return;
            }
            const id = saveSharedGame(game);
            if (!id) return;
            const shareUrl = `${window.location.href.split('?')[0]}?id=${id}`;
            if (navigator.clipboard && navigator.clipboard.write) {
                navigator.clipboard.write(shareUrl).then(() => {
                    alert('Shareable link copied to clipboard: ' + shareUrl);
                }).catch(() => {
                    showCopyPrompt(shareUrl);
                });
            } else {
                showCopyPrompt(shareUrl);
            }
        }

        function makeUniqueGameName(name) {
            let baseName = name;
            let counter = 1;
            let uniqueName = name;
            while (gameHistory.some(h => h.gameName === uniqueName)) {
                uniqueName = `${baseName} (${counter})`;
                counter++;
            }
            return uniqueName;
        }

        function saveGameState() {
            if (!isReadOnly) {
                sessionStorage.setItem('rummyGameState', JSON.stringify({
                    players,
                    round,
                    gameStarted,
                    roundScores,
                    TARGET_SCORE,
                    REJOIN_THRESHOLD,
                    gameName,
                    startDateTime,
                    isEditing
                }));
            }
        }

        function loadGameState() {
            const urlParams = new URLSearchParams(window.location.search);
            const id = urlParams.get('id');
            if (id) {
                const sharedGames = JSON.parse(sessionStorage.getItem('rummySharedGames') || '{}');
                const gameData = sharedGames[id];
                if (gameData) {
                    isReadOnly = true;
                    document.body.classList.add('read-only');
                    gameName = gameData.gameName || 'Untitled';
                    startDateTime = gameData.startDateTime || new Date().toISOString();
                    TARGET_SCORE = gameData.targetScore || 100;
                    players = gameData.players || [];
                    roundScores = gameData.roundScores || [];
                    els.leaderboardGameName.textContent = gameName;
                    els.totalBetAmount.textContent = gameData.totalBetAmount || '0.00';
                    els.playerSetup.classList.add('hidden');
                    els.scoreInput.classList.add('hidden');
                    els.gameOver.classList.add('hidden');
                    els.shareLeaderboard.classList.add('hidden');
                    updateLeaderboard();
                    updateGameHistory();
                } else {
                    alert('Invalid or expired share link.');
                    loadLocalGameState();
                }
            } else {
                loadLocalGameState();
            }
        }

        function loadLocalGameState() {
            const state = JSON.parse(sessionStorage.getItem('rummyGameState') || '{}');
            if (state.players) {
                players = state.players;
                round = state.round || 1;
                gameStarted = state.gameStarted || false;
                roundScores = state.roundScores || [];
                TARGET_SCORE = state.TARGET_SCORE || null;
                REJOIN_THRESHOLD = state.REJOIN_THRESHOLD || null;
                gameName = state.gameName || '';
                startDateTime = state.startDateTime || null;
                isEditing = state.isEditing || false;

                if (TARGET_SCORE) {
                    els.targetScore.value = TARGET_SCORE;
                    els.targetScore.disabled = true;
                    els.targetValue.textContent = TARGET_SCORE;
                    els.targetDisplay.classList.remove('hidden');
                }
                updatePlayerList();
                if (gameStarted) {
                    els.playerSetup.classList.add('hidden');
                    els.scoreInput.classList.remove('hidden');
                    if (els.gameOver && players.filter(p => !p.eliminated).length <= 1) {
                        els.scoreInput.classList.add('hidden');
                        els.gameOver.classList.remove('hidden');
                        endGame();
                    } else {
                        updateScoreForm();
                    }
                }
                updateLeaderboard();
            }
            updateGameHistory();
        }

        function saveGameHistory() {
    if (isReadOnly) return;

    const existingHistory = JSON.parse(sessionStorage.getItem('rummyGameHistory') || '[]');
    
    // Remove existing entry with same startDateTime (if any)
    const filteredHistory = existingHistory.filter(g => g.startDateTime !== startDateTime);

    const activePlayers = players.filter(p => !p.eliminated);
    const winnings = calculateWinnings();
    let result = winnings
        ? winnings.filter(w => w.winnings !== 0).map(w => `${w.name}: $${w.winnings > 0 ? '+' : ''}${w.winnings}`).join(', ')
        : 'Winnings can only be calculated if at least 40% of players are eliminated or no drops remain.';

    if (els.winnerText.textContent.includes('manually')) {
        result = `Manual End: ${result}`;
    } else if (!activePlayers.some(p => Math.floor((TARGET_SCORE - p.totalScore) / 24) > 0)) {
        result = `No Drops: ${result}`;
    }

    const gameData = {
        gameName: gameName || 'Untitled',
        startDateTime: startDateTime || new Date().toISOString(),
        targetScore: TARGET_SCORE || 100,
        totalBetAmount: calculateTotalBetAmount(),
        players: players.map(p => ({
            name: p.name,
            initialBetAmount: p.initialBetAmount,
            betAmount: p.betAmount,
            totalScore: p.totalScore,
            roundsWon: p.roundsWon,
            eliminated: p.eliminated,
            rejoinCount: p.rejoinCount,
            lastEliminatedRound: p.lastEliminatedRound,
            rejoinRounds: p.rejoinRounds
        })),
        roundScores: roundScores.map(round => ({ ...round })),
        result
    };

    // Push the new, unique entry
    filteredHistory.push(gameData);
    sessionStorage.setItem('rummyGameHistory', JSON.stringify(filteredHistory));
    updateGameHistory();
}


        function updateGameHistory() {
            gameHistory = JSON.parse(sessionStorage.getItem('rummyGameHistory') || '[]');
            els.historyTable.innerHTML = gameHistory.length === 0
                ? '<tr><td colspan="5" class="text-gray-600">No games found.</td></tr>'
                : gameHistory.map((game) => `
                    <tr>
                        <td class="p-1">${game.gameName}</td>
                        <td class="p-1">${new Date(game.startDateTime).toLocaleString()}</td>
                        <td class="p-1">${game.targetScore}</td>
                        <td class="p-1">${game.result}</td>
                        <td class="p-1 text-center">
                            <button onclick="viewGameHistory('${game.startDateTime}')" class="bg-blue-500 text-white px-2 py-1 rounded hover:bg-blue-600 ${isReadOnly ? 'hidden' : ''}">View</button>
                            <button onclick="generateHistoryShareLink('${game.startDateTime}')" class="bg-purple-500 text-white px-2 py-1 rounded hover:bg-purple-600">Share</button>
                        </td>
                    </tr>
                `).join('');
        }

        function viewGameHistory(startDateTime) {
            if (isReadOnly) return;
            const game = gameHistory.find(g => g.startDateTime === startDateTime);
            if (!game) {
                els.leaderboardTable.innerHTML = '<tr><td colspan="100" class="text-red-500">Game not found.</td></tr>';
                return;
            }

            els.leaderboardGameName.textContent = game.gameName || 'Untitled';
            els.totalBetAmount.textContent = game.totalBetAmount || '0.00';
            els.leaderboardHead.innerHTML = `<tr class="bg-gray-200"><th class="p-1">Round</th>${game.players.map(p => `<th class="p-1 ${p.eliminated ? 'text-red-500 eliminated-column' : ''}">${getPlayerDisplayName(p)}</th>`).join('')}</tr>`;
            let tableHTML = '';

            game.roundScores.forEach((roundData, index) => {
                tableHTML += `<tr><td class="p-1">${index + 1}</td>`;
                game.players.forEach(player => {
                    const score = roundData[player.name] !== undefined ? roundData[player.name] : '-';
                    const displayScore = score === 0 ? 'R' : score;
                    const isRejoinRound = player.rejoinRounds.includes(index + 1);
                    const isWinner = score === 0;
                    const isEliminationRound = player.lastEliminatedRound === index && score !== '-';
                    const cellClass = [
                        'text-center',
                        isWinner ? 'bg-green-800 text-white' : '',
                        isRejoinRound ? 'bg-amber-800 text-white' : '',
                        player.eliminated && !isWinner && !isRejoinRound ? 'eliminated-score' : ''
                    ].filter(Boolean).join(' ');
                    const eliminationMark = isEliminationRound ? '<sup class="text-red-500">E</sup>' : '';
                    tableHTML += `<td class="p-1 ${cellClass}">${displayScore}${eliminationMark}</td>`;
                });
                tableHTML += '</tr>';
            });

            // Total row with lowest/highest styling
            const activeTotals = game.players.filter(p => !p.eliminated).map(p => p.totalScore);
            const minTotal = activeTotals.length > 0 ? Math.min(...activeTotals) : null;
            const maxTotal = activeTotals.length > 0 ? Math.max(...activeTotals) : null;

            tableHTML += `<tr class="bg-gray-200"><td class="p-1 font-bold">Total</td>${game.players.map(player => {
                const pointsToTarget = game.targetScore - player.totalScore;
                const isLowest = !player.eliminated && player.totalScore === minTotal;
                const isHighest = !player.eliminated && player.totalScore === maxTotal;
                const totalCellClass = [
                    'text-center',
                    pointsToTarget === 24 ? 'bg-amber-500 text-white' : '',
                    pointsToTarget < 24 && player.totalScore <= game.targetScore ? 'bg-red-500 text-white' : '',
                    player.eliminated && pointsToTarget !== 24 && !(pointsToTarget < 24 && player.totalScore <= game.targetScore) ? 'eliminated-score' : '',
                    isLowest ? 'lowest-total' : '',
                    isHighest ? 'highest-total' : ''
                ].filter(Boolean).join(' ');
                return `<td class="p-1 ${totalCellClass}">${player.totalScore}</td>`;
            }).join('')}</tr>`;

            // Drops row
            tableHTML += `<tr class="bg-white-leaderboard"><td class="p-1 font-bold">Drops:</td>${game.players.map(player => {
                const drops = player.eliminated ? '-' : Math.round(Math.floor((game.targetScore - player.totalScore) / 24));
                const dropsCellClass = player.eliminated ? 'text-center eliminated-score' : 'text-center';
                return `<td class="p-1 ${dropsCellClass}">${drops}</td>`;
            }).join('')}</tr>`;

            // To Eliminate row
            tableHTML += `<tr class="bg-light-purple"><td class="p-1 font-bold">Oaks Rem:</td>${game.players.map(player => {
                const toEliminate = player.eliminated ? '-' : game.targetScore - player.totalScore ;
                const toEliminateCellClass = player.eliminated ? 'text-center eliminated-score' : 'text-center';
                return `<td class="p-1 ${toEliminateCellClass}">${toEliminate}</td>`;
            }).join('')}</tr>`;

            els.leaderboardTable.innerHTML = tableHTML;
        }

        function addPlayer() {
    if (isReadOnly) return;

    const input = els.playerName.value.trim();
    const betInput = parseFloat(els.betAmount.value) || 0;

    if (!input) {
        els.playerError.textContent = 'Player names are required.';
        els.playerError.classList.remove('hidden');
        return;
    }

    if (betInput < 0) {
        els.playerError.textContent = 'Bet amount must be non-negative.';
        els.playerError.classList.remove('hidden');
        return;
    }

    if (players.length > 0 && betInput !== players[0].initialBetAmount) {
        els.playerError.textContent = 'All players must have the same initial bet amount.';
        els.playerError.classList.remove('hidden');
        return;
    }

    // Prepare names
    const inputNames = input.split(',').map(name => name.trim()).filter(Boolean);
    const existingNamesLower = players.map(p => p.name.toLowerCase());

    const newNames = [];
    const duplicates = [];

    inputNames.forEach(name => {
        const formatted = formatName(name);
        if (existingNamesLower.includes(formatted.toLowerCase()) || newNames.map(n => n.toLowerCase()).includes(formatted.toLowerCase())) {
            duplicates.push(formatted);
        } else {
            newNames.push(formatted);
        }
    });

    if (duplicates.length > 0) {
        els.playerError.textContent = `Duplicate name(s): ${duplicates.join(', ')}. Please use unique names.`;
        els.playerError.classList.remove('hidden');
        return;
    }

    // Add unique players
    newNames.forEach(name => {
        players.push({
            name,
            initialBetAmount: betInput,
            betAmount: betInput,
            totalScore: 0,
            roundsWon: 0,
            eliminated: false,
            rejoinCount: 0,
            lastEliminatedRound: null,
            rejoinRounds: []
        });
    });

    els.playerName.value = '';
    els.betAmount.value = '10';
    els.playerError.classList.add('hidden');
    updatePlayerList();
    saveGameState();
}


        function updatePlayerList() {
            if (isReadOnly) return;
            els.playerList.innerHTML = players.map(player => `
                <div class="bg-gray-100 p-1 rounded flex justify-between items-center">
                    <span>${getPlayerDisplayName(player)} ($${player.betAmount.toFixed(2)})</span>
                    <button onclick="removePlayer('${player.name}')" class="bg-red-500 text-white px-2 py-1 rounded hover:bg-red-600">Remove</button>
                </div>
            `).join('');
        }

        function removePlayer(name) {
            if (isReadOnly) return;
            players = players.filter(p => p.name !== name);
            updatePlayerList();
            updateLeaderboard();
            saveGameState();
        }

        function startGame() {
            if (isReadOnly) return;
            const target = parseInt(els.targetScore.value) || 0;
            if (target < 100) {
                els.targetError.textContent = 'Target score must be at least 100.';
                els.targetError.classList.remove('hidden');
                return;
            }
            if (players.length < 2) {
                els.targetError.textContent = 'At least 2 players are required to start the game.';
                els.targetError.classList.remove('hidden');
                return;
            }
            TARGET_SCORE = target;
            REJOIN_THRESHOLD = target - 24;
            els.targetError.classList.add('hidden');
            els.targetScore.disabled = true;
            els.targetValue.textContent = TARGET_SCORE;
            els.targetDisplay.classList.remove('hidden');

            let inputName = window.prompt('Enter a name for this game (optional):', '');
            if (inputName === null || inputName.trim() === '') {
                const now = new Date();
                inputName = `${now.getFullYear()}${String(now.getMonth() + 1).padStart(2, '0')}${String(now.getDate()).padStart(2, '0')} ${String(now.getHours()).padStart(2, '0')}:${String(now.getMinutes()).padStart(2, '0')}:${String(now.getSeconds()).padStart(2, '0')}`;
            }
            gameName = makeUniqueGameName(inputName);
            startDateTime = new Date().toISOString();
            gameStarted = true;
            els.playerSetup.classList.add('hidden');
            els.scoreInput.classList.remove('hidden');
            updateScoreForm();
            updateLeaderboard();
            saveGameState();
        }

        function updateScoreForm() {
            if (isReadOnly) return;
            const isGameOver = !els.gameOver.classList.contains('hidden');
            els.scoreInputTitle.innerHTML = isEditing 
                ? `Edit Scores for Round <span id="roundNumber">${round - 1}</span>`
                : `Enter Scores for Round <span id="roundNumber">${round}</span>`;
            const activePlayers = players.filter(p => !p.eliminated);
            els.scoreForm.innerHTML = activePlayers.map(player => {
                let selectedValue = isEditing && roundScores.length > 0 
                    ? roundScores[roundScores.length - 1][player.name] 
                    : 24;
                let isEntry = isEditing && ![0, 24, 40, 80].includes(selectedValue);
                if (isEntry && selectedValue === undefined) selectedValue = '';
                return `
                    <div class="flex flex-col gap-1 w-10">
                        <label class="font-medium text-sm" title="${getPlayerDisplayName(player)}">${getPlayerDisplayName(player)}</label>
                        <select id="score_${player.name}" class="border rounded p-1 text-sm">
                            <option value="0" ${selectedValue === 0 ? 'selected' : ''}>R (0)</option>
                            <option value="24" ${selectedValue === 24 ? 'selected' : ''}>D (24)</option>
                            <option value="40" ${selectedValue === 40 ? 'selected' : ''}>MD (40)</option>
                            <option value="80" ${selectedValue === 80 ? 'selected' : ''}>FC (80)</option>
                            <option value="entry" ${isEntry ? 'selected' : ''}>Input:</option>
                        </select>
                        <input id="entry_${player.name}" type="number" placeholder="2-80" value="${isEntry ? selectedValue : ''}" class="border rounded p-1 text-sm w-10 ${isEntry ? '' : 'hidden'}" min="2" max="80">
                    </div>
                `;
            }).join('');

            activePlayers.forEach(player => {
                const select = document.getElementById(`score_${player.name}`);
                const entryInput = document.getElementById(`entry_${player.name}`);
                if (select && entryInput) {
                    select.addEventListener('change', () => {
                        entryInput.classList.toggle('hidden', select.value !== 'entry');
                    });
                }
            });

            if (isGameOver) {
                els.scoreButtons.innerHTML = '';
            } else {
                els.scoreButtons.innerHTML = `
                    <button onclick="submitScores()" class="bg-blue-500 text-white px-4 py-2 rounded hover:bg-blue-600">${isEditing ? 'Save Changes' : 'Submit Scores'}</button>
                    <button onclick="endGame(true)" class="bg-red-500 text-white px-4 py-2 rounded hover:bg-red-600">End Game</button>
                    ${roundScores.length > 0 ? `
                        <button onclick="editLastRound()" class="bg-yellow-500 text-white px-4 py-2 rounded hover:bg-yellow-600">${isEditing ? 'Cancel Edit' : 'Edit Last Round'}</button>
                    ` : ''}
                `;
            }
            els.errorMessage.classList.add('hidden');
        }

        function editLastRound() {
            if (isReadOnly || roundScores.length === 0 || !els.gameOver.classList.contains('hidden')) return;
            isEditing = !isEditing;
            updateScoreForm();
            saveGameState();
        }

        function submitScores() {
            if (isReadOnly) return;
            const scores = [];
            const errors = [];
            const currentRoundScores = {};
            let winnerCount = 0;

            const activePlayers = players.filter(p => !p.eliminated);
            activePlayers.forEach(player => {
                const select = document.getElementById(`score_${player.name}`);
                let score;
                if (select.value === 'entry') {
                    const entryInput = document.getElementById(`entry_${player.name}`);
                    score = parseInt(entryInput.value) || 0;
                    if (score < 2 || score > 80) {
                        errors.push(`${getPlayerDisplayName(player)}'s entry score must be 2-80.`);
                        entryInput.classList.add('border-red-500');
                        return;
                    }
                    entryInput.classList.remove('border-red-500');
                } else {
                    score = parseInt(select.value);
                }
                scores.push({ player, score });
                currentRoundScores[player.name] = score;
                if (score === 0) winnerCount++;
            });

            if (winnerCount !== 1) errors.push('Exactly one player must be the winner (R).');

            if (errors.length) {
                els.errorMessage.innerHTML = errors.join('<br>');
                els.errorMessage.classList.remove('hidden');
                return;
            }
            els.errorMessage.classList.add('hidden');

            if (isEditing) {
                const lastRoundScores = roundScores[roundScores.length - 1];
                players.forEach(player => {
                    const oldScore = lastRoundScores[player.name] || 0;
                    const newScore = currentRoundScores[player.name] || 0;
                    player.totalScore = player.totalScore - oldScore + newScore;
                    if (oldScore === 0) player.roundsWon -= 1;
                    if (newScore === 0) player.roundsWon += 1;
                    const wasEliminated = player.eliminated;
                    player.eliminated = player.totalScore > TARGET_SCORE;
                    if (!wasEliminated && player.eliminated) {
                        player.lastEliminatedRound = round - 1;
                    } else if (wasEliminated && !player.eliminated) {
                        player.lastEliminatedRound = null;
                    }
                });
                roundScores[roundScores.length - 1] = currentRoundScores;
                isEditing = false;
            } else {
                roundScores.push(currentRoundScores);
                round++;
                scores.forEach(({ player, score }) => {
                    player.totalScore += score;
                    if (score === 0) player.roundsWon += 1;
                    const wasEliminated = player.eliminated;
                    player.eliminated = player.totalScore > TARGET_SCORE;
                    if (!wasEliminated && player.eliminated) {
                        player.lastEliminatedRound = round - 1;
                    } else if (wasEliminated && !player.eliminated) {
                        player.lastEliminatedRound = null;
                    }
                });
            }

            const activePlayersAfter = players.filter(p => !p.eliminated);
            const canAnyoneRejoin = players.some(p => 
    p.eliminated && 
    p.lastEliminatedRound !== null && 
    round === p.lastEliminatedRound + 1 &&
    Math.max(...players.filter(p => !p.eliminated).map(p => p.totalScore)) <= REJOIN_THRESHOLD
);

if (activePlayersAfter.length <= 1 && !canAnyoneRejoin) {
    endGame();
} else {
    updateScoreForm();
    updateLeaderboard();
}
            saveGameState();
        }

        function rejoinPlayer(name) {
            if (isReadOnly) return;
            const player = players.find(p => p.name === name);
            if (!player || !player.eliminated) return;

            const activePlayers = players.filter(p => !p.eliminated);
            const maxScore = activePlayers.length ? Math.max(...activePlayers.map(p => p.totalScore)) : 0;
            if (maxScore <= REJOIN_THRESHOLD && player.lastEliminatedRound !== null && round === player.lastEliminatedRound + 1) {
                player.eliminated = false;
                player.rejoinCount += 1;
                player.betAmount += player.initialBetAmount;
                player.totalScore = maxScore;
                player.lastEliminatedRound = null;
                player.rejoinRounds.push(round);
                roundScores.forEach(round => {
                    if (!round[player.name]) round[player.name] = '-';
                });
                updateScoreForm();
                updateLeaderboard();
                saveGameState();
            } else {
                alert(`${getPlayerDisplayName(player)} cannot rejoin. Rejoin is only allowed in the next round after elimination, and the highest score (${maxScore}) must not exceed ${REJOIN_THRESHOLD}.`);
            }
        }

        function updateLeaderboard() {
            els.leaderboardGameName.textContent = gameName || 'Untitled';
            els.totalBetAmount.textContent = calculateTotalBetAmount();
            els.leaderboardHead.innerHTML = `<tr class="bg-gray-200"><th class="p-1">Round</th>${players.map(p => `<th class="p-1 ${p.eliminated ? 'text-red-500 eliminated-column' : ''}">${getPlayerDisplayName(p)}</th>`).join('')}</tr>`;
            let tableHTML = '';

            roundScores.forEach((roundData, index) => {
                tableHTML += `<tr><td class="p-1 text-center font-bold">${index + 1}</td>`;
                players.forEach(player => {
                    const score = roundData[player.name] !== undefined ? roundData[player.name] : '-';
                    const displayScore = score === 0 ? 'R' : score;
                    const isRejoinRound = player.rejoinRounds.includes(index + 1);
                    const isWinner = score === 0;
                    const isEliminationRound = player.lastEliminatedRound === index && score !== '-';
                    const cellClass = [
                        'text-center',
                        isWinner ? 'bg-green-500 font-bold text-black' : '',
                        isRejoinRound ? 'bg-amber-500 text-white' : '',
                        player.eliminated && !isWinner && !isRejoinRound ? 'eliminated-score' : ''
                    ].filter(Boolean).join(' ');
                    const eliminationMark = isEliminationRound ? '<sup class="text-red-500">E</sup>' : '';
                    tableHTML += `<td class="p-1 ${cellClass}">${displayScore}${eliminationMark}</td>`;
                });
                tableHTML += '</tr>';
            });

            // Total row with lowest/highest styling
            const activeTotals = players.filter(p => !p.eliminated).map(p => p.totalScore);
            const minTotal = activeTotals.length > 0 ? Math.min(...activeTotals) : null;
            const maxTotal = activeTotals.length > 0 ? Math.max(...activeTotals) : null;

            tableHTML += `<tr class="bg-gray-200"><td class="p-1 font-bold">Total</td>${players.map(player => {
                const pointsToTarget = TARGET_SCORE - player.totalScore;
                const isLowest = !player.eliminated && player.totalScore === minTotal;
                const isHighest = !player.eliminated && player.totalScore === maxTotal;
                const totalCellClass = [
                    'text-center',
                    pointsToTarget === 24 ? 'bg-amber-500 text-white' : '',
                    pointsToTarget < 24 && player.totalScore <= TARGET_SCORE ? 'bg-red-500 text-white' : '',
                    player.eliminated && pointsToTarget !== 24 && !(pointsToTarget < 24 && player.totalScore <= TARGET_SCORE) ? 'eliminated-score' : '',
                    isLowest ? 'lowest-total' : '',
                    isHighest ? 'highest-total' : ''
                ].filter(Boolean).join(' ');
                return `<td class="p-1 ${totalCellClass}">${player.totalScore}</td>`;
            }).join('')}</tr>`;

            // Drops row
            tableHTML += `<tr class="bg-white-leaderboard"><td class="p-1 font-bold">Drops:</td>${players.map(player => {
                const drops = player.eliminated ? '-' : Math.round(Math.floor((TARGET_SCORE - player.totalScore) / 24));
                const dropsCellClass = player.eliminated ? 'text-center eliminated-score' : 'text-center';
                return `<td class="p-1 ${dropsCellClass}">${drops}</td>`;
            }).join('')}</tr>`;

            // To Eliminate row
            tableHTML += `<tr class="bg-light-purple"><td class="p-1 font-bold">Oaks Rem:</td>${players.map(player => {
                const toEliminate = player.eliminated ? '-' : TARGET_SCORE - player.totalScore;
                const toEliminateCellClass = player.eliminated ? 'text-center eliminated-score' : 'text-center';
                return `<td class="p-1 ${toEliminateCellClass}">${toEliminate}</td>`;
            }).join('')}</tr>`;

            // Rejoin actions (hidden in read-only mode)
            if (!isReadOnly) {
                tableHTML += `<tr><td class="p-1"> Action </td>${players.map(player => {
                    const canRejoin = player.eliminated && player.lastEliminatedRound !== null && round === player.lastEliminatedRound + 1 && (players.filter(p => !p.eliminated).length > 0 && Math.max(...players.filter(p => !p.eliminated).map(p => p.totalScore)) <= REJOIN_THRESHOLD);
                    return `<td class="p-1 text-center">${canRejoin ? `<button onclick="rejoinPlayer('${player.name}')" class="bg-yellow-500 text-white px-2 py-1 rounded hover:bg-yellow-600">Rejoin</button>` : ''}</td>`;
                }).join('')}</tr>`;
            }

            els.leaderboardTable.innerHTML = tableHTML;
        }

        function endGame(isManualEnd = false) {
            if (isReadOnly || !gameStarted) return;
            els.scoreInput.classList.add('hidden');
            els.gameOver.classList.remove('hidden');
            const activePlayers = players.filter(p => !p.eliminated);
            const winnings = calculateWinnings();
            const hasDrops = activePlayers.some(p => Math.floor((TARGET_SCORE - p.totalScore) / 24) > 0);

            if (isManualEnd) {
                const dropsLeft = players
                    .filter(player => !player.eliminated)
                    .map(player => ({
                        name: getPlayerDisplayName(player),
                        drops: Math.round(Math.floor((TARGET_SCORE - player.totalScore) / 24))
                    }))
                    .sort((a, b) => a.name.localeCompare(b.name));
                els.winnerText.textContent = dropsLeft.length > 0 
                    ? `Game ended manually. Drops: ${dropsLeft.map(p => `${p.name}: ${p.drops}`).join(', ')}`
                    : 'Game ended manually. No active players.';
                els.winningsText.innerHTML = winnings && winnings.length > 0 
                    ? `Potential Winnings:<br>${winnings.map(w => `${w.name}: $${w.winnings > 0 ? '+' : ''}${w.winnings}`).join('<br>')}`
                    : 'Winnings can only be calculated if at least 40% of the players are eliminated or no drops remain.';
                els.gameOverButtons.innerHTML = `
                    <button onclick="resumeGame()" class="bg-yellow-500 text-white px-4 py-2 rounded hover:bg-yellow-600">Resume Game</button>
                    <button onclick="resetGame()" class="bg-red-500 text-white px-4 py-2 rounded hover:bg-red-600">New Game</button>
                `;
            } else if (activePlayers.length === 1) {
                els.winnerText.textContent = `Winner: ${getPlayerDisplayName(activePlayers[0])} with ${activePlayers[0].totalScore} points!`;
                els.winningsText.innerHTML = winnings && winnings.length > 0 
                    ? `Winnings:<br>${winnings.map(w => `${w.name}: $${w.winnings > 0 ? '+' : ''}${w.winnings}`).join('<br>')}`
                    : 'Winnings can only be calculated if at least 40% of the players are eliminated or no drops remain.';
                els.gameOverButtons.innerHTML = `
                    <button onclick="resetGame()" class="bg-red-500 text-white px-4 py-2 rounded hover:bg-red-600">New Game</button>
                `;
            } else if (!hasDrops) {
                els.winnerText.textContent = 'Game ended with no drops remaining.';
                els.winningsText.innerHTML = winnings && winnings.length > 0 
                    ? `Winnings (Equal Split):<br>${winnings.map(w => `${w.name}: $${w.winnings > 0 ? '+' : ''}${w.winnings}`).join('<br>')}`
                    : 'No winnings calculated.';
                els.gameOverButtons.innerHTML = `
                    <button onclick="resumeGame()" class="bg-yellow-500 text-white px-4 py-2 rounded hover:bg-yellow-600">Resume Game</button>
                    <button onclick="resetGame()" class="bg-red-500 text-white px-4 py-2 rounded hover:bg-red-600">New Game</button>
                `;
            } else {
                els.winnerText.textContent = 'Game ended with no clear winner.';
                els.winningsText.innerHTML = winnings && winnings.length > 0 
                    ? `Potential Winnings:<br>${winnings.map(w => `${w.name}: $${w.winnings > 0 ? '+' : ''}${w.winnings}`).join('<br>')}`
                    : 'Winnings can only be calculated if at least 40% of the players are eliminated or no drops remain.';
                els.gameOverButtons.innerHTML = `
                    <button onclick="resumeGame()" class="bg-yellow-500 text-white px-4 py-2 rounded hover:bg-yellow-600">Resume Game</button>
                    <button onclick="resetGame()" class="bg-red-500 text-white px-4 py-2 rounded hover:bg-red-600">New Game</button>
                `;
            }
            
            saveGameState();
            saveGameHistory();
        }

        function resumeGame() {
            if (isReadOnly || !gameStarted) return;
            els.scoreInput.classList.remove('hidden');
            els.gameOver.classList.add('hidden');
            isEditing = false;
            updateScoreForm();
            updateLeaderboard();
            saveGameState();
        }

        function resetGame() {
            if (isReadOnly) return;
            if (gameStarted) {
                saveGameHistory();
            }
            players = [];
            round = 1;
            roundScores = [];
            gameStarted = false;
            TARGET_SCORE = null;
            REJOIN_THRESHOLD = null;
            gameName = '';
            startDateTime = null;
            isEditing = false;
            els.playerSetup.classList.remove('hidden');
            els.scoreInput.classList.add('hidden');
            els.gameOver.classList.add('hidden');
            els.targetScore.disabled = false;
            els.targetScore.value = '';
            els.targetDisplay.classList.add('hidden');
            els.playerError.classList.add('hidden');
            updatePlayerList();
            updateLeaderboard();
            sessionStorage.removeItem('rummyGameState');
            updateGameHistory();
        }

        // Load game state on page load
        loadGameState();
    </script>
</body>
</html>
